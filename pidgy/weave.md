# Woven text

    import IPython, pidgy.base, traitlets, jinja2
    with pidgy.pidgyLoader(lazy=True): import pidgy.compat.templating
    class Weave(pidgy.base.Trait):
    
Nominally, since the earliest illuminated manuscripts, text is in with type and form. In [literate programming], the weave step explicitly refers to the act of converting an input source into other media forms.

The original [WEB] implementation models the properties of printed documents using the [TeX] document language.
`pidgy` shares the same concerns with the form of the published document; in fact, this workflow produces a [PDF] document using the [ReadTheDocs] open-source service with [DVI], Knuth's original woven target, as an intermediate product[^dvi].

However, prior to printed forms, `pidgy` is concerned with the ability to `Weave` hypertext and hypermedia forms generated by [literate computing] and composing documents in modern web-browsers. `pidgy` uses as a document formatting language; it is chosen because it is the default document language of `jupyter` technologies.

The source code for `pidgy` is always [Markdown], it provides both the design and computation of an input. In [pidgy]

The `Weave` class controls the display of `pidgy` outputs, and it relies on the `Weave.parent` interactive shell.

        environment = traitlets.Instance('jinja2.Environment')
    

        @pidgy.implementation
        def post_run_cell(self, result):

The `Weave` step is invoked after a cell or code has been executed.

            text = pidgy.util.strip_front_matter(result.info.raw_cell)
            lines = text.splitlines() or ['']
            if not lines[0].strip(): return

`pidgy` defers from printing the output if the first line is blank.

            text = getattr(self, self.interactive_template and 'render_interactive' or 'render')(text)

By default, `pidgy` will can transclude variables from a working program into the output creating rich data driven programs.

            text and IPython.display.display(IPython.display.Markdown(text))

## Transclusion with `jinja2` templates.

`jinja2` is a convention for notebooks in the `nbconvert` universe. `jinja2` is a popular templating engine that makes it possible to put programmatic objects into text.


        render_template = traitlets.Bool(True).tag(description=
        
`Weave.render_template` is a toggle for turning transclusion on and off.
        
        )
        interactive_template = traitlets.Bool(False).tag(description=
        
`Weave.interactive_template` is a toggle for ability to update templates each time a cell is executed ultimately creating a reactive document.
        
        )

By default templates are always rendered, but this feature can be turned off.

        def render(self, text):
            if not self.render_template: return text
            import builtins, operator
            try:
                template = self.environment.from_string(text, globals={
                    **vars(builtins), **vars(operator),
                    **(getattr(self.parent, 'user_ns', {})).get('__annotations__', {}),
                    **getattr(self.parent, 'user_ns', {})})
                return template.render()
            except BaseException as Exception: self.parent.showtraceback((type(Exception), Exception, Exception.__traceback__))
            return text

        def render_interactive(self, text):
            import builtins, operator
            display = IPython.display.display(IPython.display.Markdown(text), display_id=True)
            while self.environment.last_widgets:
                self.environment.last_widgets.pop(-1).observe(lambda change: display.update(IPython.display.Markdown(self.render(text))), 'value')
            
            

        @traitlets.default('environment')
        def _default_environment(self): 

More information about the default `jinja2` environment may be found in the [compatability module].

            return pidgy.compat.templating.environment()
